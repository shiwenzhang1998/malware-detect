from model import Network
from transform import Transform
import torch
import argparse
import torch
import torchvision
import os
import torch.nn as nn
from torch.utils.data import Dataset
from tqdm import tqdm
import sys
import pandas as pd
from utils.byte2jpg import saveimg
import numpy as np
import shutil

device = torch.device('cuda:2' if torch.cuda.is_available() else 'cpu')

def print_args(args):
    if not args.model.endswith(".pth"):
        print("Invalid input model, test failed !")
        sys.exit(-1)

    if not args.input:
        print("Invalid input datapath, test failed !")
        sys.exit(-1)

    if os.path.isfile(args.input):
        if not args.input.endswith(".bytes"):
            print("Invalid input data !")
    else:
        file_flag = False
        for root,dir,files in os.walk(args.input):
            for file in files:
                if file.endswith(".bytes"):
                    file_flag = True
                    break
        if not file_flag:
            print("Invalid input data !")
            sys.exit(-1)

    print("========================================")
    print("         Using device: {}               ".format(str(device)))
    print("         Load Model: {}                 ".format(os.path.basename(args.model)))
    print("         Test DataPath: {}                  ".format(args.input))
    print("========================================")

def init_result_dict():
    result_dict = {}
    for i in range(9):
        result_dict[i] = 0
    return result_dict

def transform_byte2jpg(input_path):
    data_root = input_path
    origin_data_filename = ""
    save_data_filename = "malware_images/"

    origin_data_path =os.path.join(data_root ,origin_data_filename)
    save_data_path = os.path.join(data_root ,save_data_filename)

    labelPath = "./trainLabels.csv"

    label_df = pd.read_csv(labelPath)
    label_value = label_df.values
    label_dict = {}

    for filename, label in label_value:
        label_dict[filename] = label
    files = os.listdir(origin_data_path)
    c = 0

    for id in range(1,10):
        save_data_subpath = save_data_path + "{}/".format(id)
        if not os.path.exists(save_data_subpath):
            os.makedirs(save_data_subpath)

    for _, x in enumerate(files):
        if not x.endswith(".bytes"):
            continue
        try:
            x_name = x.split(".")[0]
            x_label = label_dict[x_name]
            save_data_subpath = save_data_path + "{}/".format(x_label)
            if not os.path.exists(save_data_subpath):
                os.makedirs(save_data_subpath)

            f = open(origin_data_path + x)
            array = []
            c += 1
            for line in f:
                xx = line.split()
                if len(xx) != 17:
                    continue
                array.append([int(i, 16) if i != '??' else 0 for i in xx[1:]])
            saveimg(np.array(array), x, save_data_subpath)
            del array
            f.close()
        except:
            sys.exit(-1)

    print("========= Bytes2Jpeg Finished ==========")
    return save_data_path

def transform_single_byte2jpg(input_path):
    data_root = os.path.dirname(input_path)
    save_data_filename = "malware_images/"

    save_data_path = os.path.join(data_root ,save_data_filename)

    labelPath = "./trainLabels.csv"

    label_df = pd.read_csv(labelPath)
    label_value = label_df.values
    label_dict = {}

    for filename, label in label_value:
        label_dict[filename] = label

    for id in range(1,10):
        save_data_subpath = save_data_path + "{}/".format(id)
        if not os.path.exists(save_data_subpath):
            os.makedirs(save_data_subpath)


    filename = os.path.basename(input_path)
    try:
        x_name = filename.split(".")[0]
        x_label = label_dict[x_name]
        save_data_subpath = save_data_path + "{}/".format(x_label)
        if not os.path.exists(save_data_subpath):
            os.makedirs(save_data_subpath)

        f = open(input_path)
        array = []
        for line in f:
            xx = line.split()
            if len(xx) != 17:
                continue
            array.append([int(i, 16) if i != '??' else 0 for i in xx[1:]])
        saveimg(np.array(array), filename, save_data_subpath)
        del array
        f.close()
    except:
        sys.exit(-1)

    print("========= Bytes2Jpeg Finished ==========")
    return save_data_path

def test_dir(net, testloader):
    total_images = 0
    total_correct = 0
    total_dict = init_result_dict()
    correct_dict = init_result_dict()

    with torch.no_grad():
        for data in tqdm(testloader, leave=False, total=len(testloader)):
            images, labels = data
            images = images.to(device)
            labels = labels.to(device)
            outputs = net(images)
            _, predicted = torch.max(outputs.data, 1)
            total_images += labels.size(0)
            total_correct += (predicted == labels).sum().item()

            labels = labels.cpu().numpy()
            predicted = predicted.cpu().numpy()
            for pair in zip(labels, predicted):
                label, predict = pair
                total_dict[label] += 1
                if label == predict:
                    correct_dict[label] += 1

    model_accuracy = total_correct / total_images * 100
    print("============== Test Result =============")
    print("  Test on {0} images".format(
        total_images))
    print('  Accuracy on all : {0:.2f}%'.format(model_accuracy))
    for label_id in range(9):
        if total_dict[label_id] != 0:
            print('  Accuracy on class {0} : {1:.2f}%'.format(
                label_id,correct_dict[label_id] / total_dict[label_id] * 100))
        else:
            print("  No class {} data".format(label_id))


def test_file(net, testloader, input):
    total_images = 0
    total_correct = 0
    total_dict = init_result_dict()
    correct_dict = init_result_dict()

    with torch.no_grad():
        for data in testloader:
            images, labels = data
            images = images.to(device)
            labels = labels.to(device)
            outputs = net(images)
            _, predicted = torch.max(outputs.data, 1)
            total_images += labels.size(0)
            total_correct += (predicted == labels).sum().item()

            labels = labels.cpu().numpy()
            predicted = predicted.cpu().numpy()
            for pair in zip(labels, predicted):
                label, predict = pair
                total_dict[label] += 1
                if label == predict:
                    correct_dict[label] += 1

    print("Test Result:")
    print("Test on {0}".format(os.path.basename(input)))
    for label_id in range(9):
        if total_dict[label_id] != 0:
            print('Ground truth is class {} '.format(label_id + 1))
        if correct_dict[label_id] !=0:
            print('Predict result is class {} '.format(label_id + 1))


def malware_detection(model_path,input):
    ########################################################################
    #######                      Loading Data                        #######
    ########################################################################
    net = Network()
    checkpoint = torch.load(model_path,map_location="cpu")
    net.load_state_dict(checkpoint)
    net.to(device)
    net.eval()
    print("======= Model Load Successfully ========")
    if os.path.isdir(input):
        image_path = transform_byte2jpg(input_path=input)
        testset = torchvision.datasets.ImageFolder(root=image_path,
                                                   transform=Transform('test'))
        testloader = torch.utils.data.DataLoader(testset,
                                                 batch_size=1,
                                                 shuffle=False)
        test_dir(net, testloader)
        shutil.rmtree(image_path)

    else:
        image_path = transform_single_byte2jpg(input_path=input)
        testset = torchvision.datasets.ImageFolder(root=image_path,
                                                   transform=Transform('test'))
        testloader = torch.utils.data.DataLoader(testset,
                                                 batch_size=1,
                                                 shuffle=False)
        test_file(net, testloader, input)
        shutil.rmtree(image_path)

if __name__ =="__main__":
    parser = argparse.ArgumentParser(description="malware detection")
    parser.add_argument('-i', '--input',
                        type=str,
                        default="",
                        help="input data, you can input single pictures or datapath")
    parser.add_argument('-m', '--model',
                        type=str,
                        default="checkModel.pth",
                        help="torch model")

    args = parser.parse_args()
    if "\\" in args.input:
        args.input = '/'.join(args.input.split('\\'))

    print_args(args)
    malware_detection(args.model,args.input)
