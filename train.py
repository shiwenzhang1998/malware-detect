from model import Network
from loss import CLSloss
from transform import Transform
import torch
import torch
import torchvision
import torch.nn as nn
from torch.utils.data import Dataset, random_split
from tqdm import tqdm
from config import train_config
device = torch.device('cuda:2' if torch.cuda.is_available() else 'cpu')

class DatasetFromSubset(Dataset):
    def __init__(self, subset, transform=None):
        self.subset = subset
        self.transform = transform

    def __getitem__(self, index):
        x, y = self.subset[index]
        if self.transform:
            x = self.transform(x)
        return x, y

    def __len__(self):
        return len(self.subset)

def mytest_network(net, testloader):
    net.eval()
    total_images = 0
    total_correct = 0
    total_dict = init_result_dict()
    correct_dict = init_result_dict()

    with torch.no_grad():
        for data in testloader:
            images, labels = data
            images = images.to(device)
            labels = labels.to(device)
            outputs = net(images)
            _, predicted = torch.max(outputs.data, 1)
            total_images += labels.size(0)
            total_correct += (predicted == labels).sum().item()

            labels = labels.cpu().numpy()
            predicted = predicted.cpu().numpy()
            for pair in zip(labels, predicted):
                label, predict = pair
                total_dict[label] += 1
                if label == predict:
                    correct_dict[label] += 1

    model_accuracy = total_correct / total_images * 100
    print('      Accuracy on {0} test images: {1:.2f}%'.format(
        total_images, model_accuracy))
    for label_id in range(9):
        print('      label{0}_correct: {1} acc: {2:.2f}'.format(
            label_id, correct_dict[label_id], correct_dict[label_id] / total_dict[label_id]))
    net.train()


def init_result_dict():
    result_dict = {}
    for i in range(9):
        result_dict[i] = 0
    return result_dict

def main():
    print("Using device: {}"
          "\n".format(str(device)))
    ########################################################################
    #######                      Loading Data                        #######
    ########################################################################
    trainset = torchvision.datasets.ImageFolder(root=train_config.train_dataset,
                                                    transform=Transform('train'))
    testset = torchvision.datasets.ImageFolder(root=train_config.test_dataset,
                                                   transform=Transform('test'))

    trainloader = torch.utils.data.DataLoader(trainset,
                                                  batch_size=train_config.batch_size, shuffle=True)
    testloader = torch.utils.data.DataLoader(testset,
                                                 batch_size=train_config.batch_size, shuffle=False)

    net = Network().to(device)
    # net=nn.DataParallel(net)
    criterion = CLSloss()
    optimiser = torch.optim.SGD(net.parameters(), lr=1e-2, momentum=0.9)

    ########################################################################
    #######                        Training                          #######
    ########################################################################
    print("Start training...")
    for epoch in range(1, train_config.epochs + 1):
        total_loss = 0
        total_images = 0
        total_correct = 0

        total_dict = init_result_dict()
        correct_dict = init_result_dict()

        for batch in tqdm(trainloader, leave=False, total=len(trainloader)):  # Load batch
            images, labels = batch
            images = images.to(device)
            labels = labels.to(device)

            preds = net(images)  # Process batch

            loss = criterion(preds, labels)  # Calculate loss
            optimiser.zero_grad()
            loss.backward()  # Calculate gradients
            optimiser.step()  # Update weights

            output = preds.argmax(dim=1)

            total_loss += loss.item()
            total_images += labels.size(0)
            total_correct += output.eq(labels).sum().item()

            labels = labels.cpu().numpy()
            output = output.cpu().numpy()
            for pair in zip(labels, output):
                label, predict = pair
                total_dict[label] += 1
                if label == predict:
                    correct_dict[label] += 1

        model_accuracy = total_correct / total_images * 100
        print('epoch {0} total_correct: {1} loss: {2:.2f} acc: {3:.2f}'.format(
            epoch, total_correct, total_loss, model_accuracy))
        for label_id in range(9):
            print('          label{0}_correct: {1} acc: {2:.2f}'.format(
                label_id, correct_dict[label_id], correct_dict[label_id] / total_dict[label_id]))

        if epoch % 10 == 0:
            if train_config.train_and_val:
                mytest_network(net, testloader)
            torch.save(net.state_dict(), 'checkModel.pth')
            print("      Model saved to checkModel.pth")

    if train_config.train_and_val:
        mytest_network(net, testloader)
    torch.save(net.state_dict(), 'savedModel.pth')
    print("   Model saved to savedModel.pth")

if __name__ =="__main__":
    torch.manual_seed(0)
    torch.manual_seed(torch.initial_seed())
    main()


